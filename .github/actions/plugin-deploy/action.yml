name: "Plugin Deployment"
description: "Deploys a plugin to Deno Deploy with necessary transformations"
inputs:
  token:
    description: "Deno Deploy access token."
    required: true
  pluginEntry:
    description: "Path to the plugin entry file"
    required: false
    default: "./worker"
  organization:
    description: "Organization for deployment (optional)"
    required: false
outputs:
  deployment_url:
    description: "The deployment URL"
    value: ${{ steps.deploy.outputs.deployment_url }}
  project_name:
    description: "The generated Deno project name"
    value: ${{ steps.generate-project.outputs.project_name }}
runs:
  using: "composite"
  steps:
    # Setup Deno first (needed for env generation)
    - name: Setup Deno
      uses: denoland/setup-deno@v2
      with:
        deno-version: v2.x

    # Generate project name
    - name: Generate Project Name
      id: generate-project
      shell: bash
      run: |
        # Get branch name
        if [ -n "${{ github.event.workflow_run.head_branch }}" ]; then
          branch_name="${{ github.event.workflow_run.head_branch }}"
        elif [ -n "${{ github.head_ref }}" ]; then
          branch_name="${{ github.head_ref }}"
        else
          branch_name="${GITHUB_REF#refs/heads/}"
        fi

        # Determine base name from package.json or repository
        if [ -f package.json ]; then
          base_name=$(jq -r .name package.json 2>/dev/null)
          [[ "$base_name" == "null" || -z "$base_name" ]] && base_name="${GITHUB_REPOSITORY##*/}"
        else
          base_name="${GITHUB_REPOSITORY##*/}"
        fi

        # Sanitize branch name
        sanitized_branch=$(echo "$branch_name" | sed 's#/#--#g' | sed 's#[^a-zA-Z0-9-]#-#g')

        # Combine and truncate if needed
        project_name="${base_name}-${sanitized_branch}"
        if [ ${#project_name} -gt 26 ]; then
          project_prefix=$(echo "$base_name" | cut -c 1-10)
          branch_hash=$(echo "$branch_name" | sha256sum | cut -c 1-8)
          project_name="${project_prefix}-${branch_hash}"
        fi

        echo "project_name=$project_name" >> $GITHUB_OUTPUT
        echo "Generated project name: $project_name"

        # Set environment variables
        echo "DENO_PROJECT_NAME=$project_name" >> $GITHUB_ENV
        DENO_DEPLOYMENT_ID=${{ github.sha }}
        echo "DENO_DEPLOYMENT_ID=$DENO_DEPLOYMENT_ID" >> $GITHUB_ENV

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'

    - name: Prepare Plugin for Deno
      shell: bash
      run: |
        # Extract plugin directory from entry path
        FULL_PATH="${{ inputs.pluginEntry }}"
        PLUGIN_DIR=$(echo "$FULL_PATH" | sed 's|/src/.*||')
        
        # Install dependencies
        cd "$PLUGIN_DIR"
        npm install --legacy-peer-deps
        
        # Go back to root
        cd -
        
        echo "Plugin dependencies installed in: ${PLUGIN_DIR}"

    - name: Generate .env File
      id: generate_env
      shell: bash
      run: |
        # Create a temporary directory for the .env file
        TEMP_ENV_DIR="${RUNNER_TEMP}/deno-deploy-env"
        mkdir -p "$TEMP_ENV_DIR"
        ENV_FILE_PATH="$TEMP_ENV_DIR/.env"

        cat > generate-env.ts <<'EOF'
        const envVars = Deno.env.toObject();
        const filtered = Object.entries(envVars)
          .filter(([k, v]) => !/^(GITHUB_|RUNNER_|CI|HOME|PATH|PWD|SHELL|USER|LANG|LC_|TZ|ACTIONS_)/.test(k))
          .filter(([k, v]) => v !== undefined && v !== null && v.trim() !== "")
          .reduce((acc, [k,v]) => ({...acc, [k]:v}), {});

        const envPath = Deno.args[0];
        await Deno.writeTextFile(envPath,
          Object.entries(filtered)
            .map(([k,v]) => `${k}="${v.replace(/"/g, '\\"')}"`)
            .join("\n")
        );
        EOF

        deno run --allow-env --allow-write="$TEMP_ENV_DIR" generate-env.ts "$ENV_FILE_PATH"
        rm generate-env.ts

        echo "env_file_path=$ENV_FILE_PATH" >> $GITHUB_OUTPUT
        echo "Generated .env file at: $ENV_FILE_PATH"

    - name: Create Deno Entry Point
      shell: bash
      run: |
        # Get plugin directory path
        FULL_PATH="${{ inputs.pluginEntry }}"
        PLUGIN_DIR=$(echo "$FULL_PATH" | sed 's|/src/.*||')
        
        # Copy necessary plugin files to root
        cp -r "${PLUGIN_DIR}/src" ./
        cp "${PLUGIN_DIR}/manifest.json" ./manifest.json || true
        
        # Generate import maps dynamically from package.json
        cat > generate-import-map.js <<'EOF'
        const fs = require('fs');
        const path = require('path');
        
        // Read package.json from plugin directory
        const pluginDir = process.argv[2];
        const packageJsonPath = path.join(pluginDir, 'package.json');
        const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
        
        // Start with base configuration
        const denoConfig = {
          compilerOptions: {
            allowJs: true,
            lib: ["deno.window"],
            strict: false
          },
          nodeModulesDir: true,
          unstable: ["sloppy-imports", "node-globals"],
          imports: {
            // Add local path mappings
            "../manifest.json": "./manifest.json",
            "./index": "./src/index.ts",
            "./types": "./src/types/index.ts"
          }
        };
        
        // Add dependencies to import map
        const deps = { ...packageJson.dependencies, ...packageJson.devDependencies };
        for (const [pkg, version] of Object.entries(deps)) {
          // Skip Node.js built-ins and local packages
          if (pkg.startsWith('node:') || pkg.startsWith('.') || pkg.startsWith('/')) continue;
          
          // Clean version string (remove ^, ~, etc)
          const cleanVersion = version.replace(/^[\^~]/, '');
          
          // Add main package import
          denoConfig.imports[pkg] = `npm:${pkg}@${cleanVersion}`;
          
          // Add subpath imports (for packages like @ubiquity-os/plugin-sdk/manifest)
          denoConfig.imports[`${pkg}/`] = `npm:${pkg}@${cleanVersion}/`;
          
          // Add common subpath imports for known packages
          if (pkg === '@ubiquity-os/plugin-sdk') {
            denoConfig.imports[`${pkg}/manifest`] = `npm:${pkg}@${cleanVersion}/dist/manifest.js`;
          }
        }
        
        // Write deno.json
        fs.writeFileSync('deno.json', JSON.stringify(denoConfig, null, 2));
        console.log('Generated deno.json with import maps');
        EOF
        
        # Run the import map generator
        node generate-import-map.js "${PLUGIN_DIR}"
        rm generate-import-map.js
        
        echo "Copied plugin files to root directory and generated import maps"


    - name: Check if manifest.json exists and copy to root
      id: check_manifest
      shell: bash
      run: |
        # Check for manifest.json in plugin directory first
        if [ -f plugins/plugin-template/manifest.json ]; then
          echo "Found manifest.json in plugin directory, copying to root"
          cp plugins/plugin-template/manifest.json ./manifest.json
          echo "exists=true" >> $GITHUB_OUTPUT
        elif [ -f manifest.json ]; then
          echo "Found manifest.json in root directory"
          echo "exists=true" >> $GITHUB_OUTPUT
        else
          echo "No manifest.json found"
          echo "exists=false" >> $GITHUB_OUTPUT
        fi

    - name: Update manifest.json with deployment URL
      if: steps.check_manifest.outputs.exists == 'true'
      shell: bash
      run: |
        set -euo pipefail

        # Construct the deployment URL
        DEPLOYMENT_URL="https://${{ steps.generate-project.outputs.project_name }}.deno.dev"
        echo "Updating manifest.json with deployment URL: $DEPLOYMENT_URL"

        # Create a Node.js script to update the manifest
        cat > update-manifest.js <<'EOF'
        const fs = require('fs');
        const path = require('path');

        const manifestPath = path.resolve(process.cwd(), './manifest.json');
        const deploymentUrl = process.argv[2];

        if (!fs.existsSync(manifestPath)) {
          console.error('manifest.json not found');
          process.exit(1);
        }

        try {
          const manifest = JSON.parse(fs.readFileSync(manifestPath, 'utf8'));
          manifest["homepage_url"] = deploymentUrl;

          const updatedManifest = JSON.stringify(manifest, null, 2);
          fs.writeFileSync(manifestPath, updatedManifest);
          console.log('Successfully updated manifest.json');
          console.log('Updated content:', updatedManifest);
        } catch (error) {
          console.error('Error updating manifest.json:', error);
          process.exit(1);
        }
        EOF

        # Run the Node.js script
        node update-manifest.js "$DEPLOYMENT_URL"

        # Clean up
        rm update-manifest.js

        # Format the manifest.json file with deno fmt if available
        if command -v deno &> /dev/null; then
          deno fmt --ext=json manifest.json || true
        fi

    - name: Deploy to Deno
      id: deploy
      uses: ./.github/actions/deno-deploy
      with:
        token: ${{ inputs.token }}
        action: "deploy"
        project_name: ${{ steps.generate-project.outputs.project_name }}
        entrypoint: src/worker.ts
        env_file: ${{ steps.generate_env.outputs.env_file_path }}
        organization: "${{ inputs.organization }}"
        skip_checkout: "true"
